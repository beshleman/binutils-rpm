diff -Nrup a/bfd/elf.c b/bfd/elf.c
--- a/bfd/elf.c	2015-03-11 13:45:12.623830701 -0600
+++ b/bfd/elf.c	2015-03-11 13:58:14.127506851 -0600
@@ -4293,11 +4293,7 @@ _bfd_elf_map_sections_to_segments (bfd *
 			== (SEC_LOAD | SEC_HAS_CONTENTS))
 		      break;
 
-		  if (i == (unsigned) -1)
-		    continue;
-
-		  if (m->sections[i]->vma + m->sections[i]->size
-		      >= info->relro_end)
+		  if (i != (unsigned) -1)
 		    break;
 		}
 	    }
@@ -4486,6 +4482,7 @@ assign_file_positions_for_load_sections
   unsigned int alloc;
   unsigned int i, j;
   bfd_vma header_pad = 0;
+  bfd_vma relro_start = 0, relro_end = 0;
 
   if (link_info == NULL
       && !_bfd_elf_map_sections_to_segments (abfd, link_info))
@@ -4556,6 +4553,23 @@ assign_file_positions_for_load_sections
     header_pad -= off;
   off += header_pad;
 
+  /* Get start and end of PT_GNU_RELRO segment.  */
+  if (link_info != NULL)
+    {
+      relro_start = link_info->relro_start;
+      relro_end = link_info->relro_end;
+    }
+  else
+    {
+      for (m = elf_seg_map (abfd); m != NULL; m = m->next)
+	if (m->p_type == PT_GNU_RELRO)
+	  {
+	    relro_start = m->p_paddr;
+	    relro_end = relro_start + m->p_size;
+	    break;
+	  }
+    }
+
   for (m = elf_seg_map (abfd), p = phdrs, j = 0;
        m != NULL;
        m = m->next, p++, j++)
@@ -4899,6 +4913,23 @@ assign_file_positions_for_load_sections
 		p->p_flags |= PF_W;
 	    }
 	}
+
+      if (relro_start != 0
+	  && p->p_type == PT_LOAD
+	  && p->p_vaddr >= relro_start)
+	{
+	  /* If PT_LOAD segment doesn't fit PT_GNU_RELRO segment,
+	     adjust its p_filesz and p_memsz.  */
+	  if (p->p_vaddr + p->p_filesz < relro_end)
+	    {
+	      bfd_vma adjust = relro_end - (p->p_vaddr + p->p_filesz);
+	      p->p_filesz += adjust;
+	      off += adjust;
+	    }
+	  if (p->p_vaddr + p->p_memsz < relro_end)
+	    p->p_memsz += relro_end - (p->p_vaddr + p->p_memsz);
+	}
+
       off -= off_adjust;
 
       /* Check that all sections are in a PT_LOAD segment.
diff -Nrup a/ld/ldlang.c b/ld/ldlang.c
--- a/ld/ldlang.c	2013-02-27 13:28:03.000000000 -0700
+++ b/ld/ldlang.c	2015-03-11 13:58:14.128506829 -0600
@@ -5424,7 +5424,8 @@ lang_size_sections (bfd_boolean *relax,
 	    {
 	      if (expld.dataseg.base - (1 << max_alignment_power) < old_base)
 		expld.dataseg.base += expld.dataseg.pagesize;
-	      expld.dataseg.base -= (1 << max_alignment_power);
+	      /* Properly align base to max_alignment_power.  */
+	      expld.dataseg.base &= ~((1 << max_alignment_power) - 1);
 	      lang_reset_memory_regions ();
 	      one_lang_size_sections_pass (relax, check_regions);
 	    }
diff -Nrup a/ld/testsuite/ld-elf/pr16322.d b/ld/testsuite/ld-elf/pr16322.d
--- a/ld/testsuite/ld-elf/pr16322.d	1969-12-31 17:00:00.000000000 -0700
+++ b/ld/testsuite/ld-elf/pr16322.d	2015-03-11 13:58:14.128506829 -0600
@@ -0,0 +1,7 @@
+#ld: -shared -z relro
+#readelf: -l --wide
+#target: *-*-linux-gnu *-*-gnu* *-*-nacl*
+
+#...
+  GNU_RELRO .*
+#pass
diff -Nrup a/ld/testsuite/ld-elf/pr16322.s b/ld/testsuite/ld-elf/pr16322.s
--- a/ld/testsuite/ld-elf/pr16322.s	1969-12-31 17:00:00.000000000 -0700
+++ b/ld/testsuite/ld-elf/pr16322.s	2015-03-11 13:58:14.128506829 -0600
@@ -0,0 +1,6 @@
+	.globl	p1
+	.section	.data.rel.ro,"aw",%progbits
+	.p2align 5
+	.type	p1, %object
+p1:
+	.dc.a	f1
diff -Nrup a/ld/testsuite/ld-x86-64/pr14207.d b/ld/testsuite/ld-x86-64/pr14207.d
--- a/ld/testsuite/ld-x86-64/pr14207.d	2013-02-27 13:28:03.000000000 -0700
+++ b/ld/testsuite/ld-x86-64/pr14207.d	2015-03-11 13:58:14.128506829 -0600
@@ -2,8 +2,23 @@
 #as: --64
 #ld: -melf_x86_64 -shared -z relro -z now
 #readelf: -l --wide
+#target: x86_64-*-linux*
 
-#failif
-#...
-  NULL +.*
-#...
+Elf file type is DYN \(Shared object file\)
+Entry point 0x1dc
+There are 4 program headers, starting at offset 64
+
+Program Headers:
+  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
+  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x0001e0 0x0001e0 R   0x200000
+  LOAD           0x000b48 0x0000000000200b48 0x0000000000200b48 0x0004b8 0x000cf8 RW  0x200000
+  DYNAMIC        0x000b90 0x0000000000200b90 0x0000000000200b90 0x0001c0 0x0001c0 RW  0x8
+  GNU_RELRO      0x000b48 0x0000000000200b48 0x0000000000200b48 0x0004b8 0x0004b8 R   0x1
+
+ Section to Segment mapping:
+  Segment Sections...
+   00     .hash .dynsym .dynstr 
+   01     .init_array .fini_array .jcr .data.rel.ro .dynamic .got .bss 
+   02     .dynamic 
+   03     .init_array .fini_array .jcr .data.rel.ro .dynamic .got 
+#pass
